排序插件扩展方向
一、 针对 Actor 的实用排序扩展

按组件属性排序

场景： AI需优先攻击血量最低的敌人。

实现： 通过反射（Reflection）获取指定组件（如 HealthComponent）中某个变量（如 Health）的值进行排序。

按 Gameplay Tag 排序

场景： 需要优先处理拥有特定状态（如眩晕）的单位，或按 Boss、精英、小兵的顺序进行攻击。

实现：

将拥有特定Tag的Actor排在最前面。

或根据一个预设的Tag列表作为优先级顺序进行分段排序。

按类或接口排序

场景： 在一次范围检测后，按“敌人”、“中立单位”、“可交互物”的顺序进行分类处理。

实现： 提供一个类（Class）或接口（Interface）的列表作为优先级，并据此排序。

按屏幕空间位置排序

场景： 框选单位后，按屏幕从左到右的顺序将头像显示在UI中。

实现： 将Actor的世界坐标转为屏幕坐标，再根据X或Y值排序。

二、 针对位置和路径的排序

沿样条线（Spline）排序

场景： 赛车游戏排名，或判断多个单位在同一条巡逻路径上的前后顺序。

实现： 计算每个Actor在目标样条线上的投影位置，并根据沿样条线的距离进行排序。

三、 针对通用数据和结构体的排序

按自定义结构体（Struct）变量排序

场景： 在蓝图中对背包物品（结构体数组）按“稀有度”或“价格”等内部变量进行排序。

实现（高级）：

创建一个接受通配符（Wildcard）数组的蓝图节点。

在节点上提供一个FName输入框，让用户填写要排序的变量名。

在C++中利用反射系统，找到结构体中对应的变量并获取其值进行排序。
