# 自动规范命名功能 - 导入检测问题分析与解决方案

## 问题诊断

### 用户反馈
> "部分情况的导入文件并不会主动触发"

### 代码分析结果

当前实现使用 3 个委托检测资产导入：

```cpp
// Source/X_AssetEditor/Private/AssetNaming/X_AssetNamingDelegates.cpp

// 1. OnAssetPostImport - 导入时触发（仅部分场景）
OnAssetPostImportHandle = ImportSubsystem->OnAssetPostImport.AddRaw(...);

// 2. OnAssetAdded - 资产添加时触发（依赖 Factory 时间窗）
OnAssetAddedHandle = AssetRegistry.OnAssetAdded().AddRaw(...);

// 3. OnNewAssetCreated - Factory 创建时触发（用于时间窗）
OnNewAssetCreatedHandle = FEditorDelegates::OnNewAssetCreated.AddRaw(...);
```

### 问题根源

#### 1. OnAssetPostImport 触发条件有限

**适用场景**：
- ✅ Content Browser → Import 按钮
- ✅ Content Browser → 右键 → Import Asset

**不适用场景**：
- ❌ 从 Windows 资源管理器拖拽文件到 Content Browser
- ❌ 批量导入（多个文件拖入）
- ❌ 命令行导入
- ❌ 脚本自动化导入

#### 2. Factory 时间窗机制依赖 OnNewAssetCreated

**代码位置**: `X_AssetNamingDelegates.cpp:262-320`

```cpp
// 只有当 OnNewAssetCreated 在短时间内触发时，才认为是导入操作
if (TimeSinceLastFactory > FactoryTimeWindow)
{
    UE_LOG(LogX_AssetNamingDelegates, Verbose,
        TEXT("跳过自动重命名：非 Factory 创建流程"));
    return false;
}
```

**问题**：
- 拖拽导入可能不触发 `FEditorDelegates::OnNewAssetCreated`
- 导致 `OnAssetAdded` 被错误地判断为"非导入操作"而跳过

#### 3. 启动延迟问题

```cpp
// OnFilesLoaded 后延迟激活（默认 30 秒）
const float ActivationDelay = Settings ? Settings->StartupActivationDelay : 30.0f;
```

**问题**：
- 启动后 30 秒内的导入操作会被忽略
- 如果用户在启动时立即拖入文件，不会被重命名

## 解决方案

### 方案 A：改进 Factory 时间窗机制（推荐，最小改动）

**核心思路**：降低对 `OnNewAssetCreated` 的依赖，添加备用检测通道

#### 修改点 1：降低 Factory 时间窗的权重

```cpp
// 修改前：完全依赖 Factory 时间窗
if (TimeSinceLastFactory > FactoryTimeWindow)
{
    return false;  // 直接跳过
}

// 修改后：Factory 时间窗仅作为"优先级提示"，而非硬性过滤条件
bool bIsLikelyFactoryCreation = (TimeSinceLastFactory <= FactoryTimeWindow);
if (!bIsLikelyFactoryCreation)
{
    // 不再直接跳过，而是继续检查其他条件
    UE_LOG(LogX_AssetNamingDelegates, Verbose,
        TEXT("Factory 时间窗未命中，继续备用检测"));
}
```

#### 修改点 2：添加文件时间戳检测（备用通道）

```cpp
// 在 OnAssetAdded 中添加新的检测逻辑
bool FX_AssetNamingDelegates::ShouldProcessAsset(const FAssetData& AssetData) const
{
    // ... 现有检查 ...

    // ========== 新增：文件时间戳检测 ==========
    if (!bIsLikelyFactoryCreation)
    {
        // 检查资产的 .uasset 文件是否最近创建
        FString PackagePath = AssetData.PackageName.ToString();
        FString DiskPath = FPackageName::LongPackageNameToFilename(PackagePath, TEXT(".uasset"));

        if (IPlatformFile::GetPlatformPhysical().FileExists(*DiskPath))
        {
            FDateTime CreationTime = IPlatformFile::GetPlatformPhysical().GetCreationTime(*DiskPath);
            FDateTime ModifiedTime = IPlatformFile::GetPlatformPhysical().GetTimeStamp(*DiskPath);
            FDateTime CurrentTime = FDateTime::Now();
            FTimespan TimeSinceCreation = CurrentTime - CreationTime;

            // 如果文件创建时间在时间窗内（10 秒），且创建时间等于修改时间（新文件）
            const float FileTimeWindow = 10.0f;
            if (TimeSinceCreation.GetTotalSeconds() <= FileTimeWindow && CreationTime == ModifiedTime)
            {
                UE_LOG(LogX_AssetNamingDelegates, Log,
                    TEXT("检测到导入资产（文件时间戳备用通道）: %s (创建于 %.1f 秒前)"),
                    *AssetData.AssetName.ToString(), TimeSinceCreation.GetTotalSeconds());
                return true;  // 确认为导入操作
            }
        }

        // 如果所有备用检测都失败，则跳过
        UE_LOG(LogX_AssetNamingDelegates, Verbose,
            TEXT("所有检测通道均未命中，跳过: %s"), *AssetData.AssetName.ToString());
        return false;
    }

    return true;
}
```

### 方案 B：添加 OnPathAdded 监听（全面，但需要更多改动）

**核心思路**：监听文件夹添加事件，间接检测导入操作

#### 新增委托绑定

```cpp
// 在 Initialize() 中添加
OnPathAddedHandle = AssetRegistry.OnPathAdded().AddRaw(
    this, &FX_AssetNamingDelegates::OnPathAdded
);

// 新增回调函数
void FX_AssetNamingDelegates::OnPathAdded(const FString& InPath)
{
    UE_LOG(LogX_AssetNamingDelegates, Verbose, TEXT("检测到新路径添加: %s"), *InPath);

    // 延迟检查该路径下的资产
    TWeakPtr<FX_AssetNamingDelegates> WeakSelf = AsShared();
    FTSTicker::GetCoreTicker().AddTicker(FTickerDelegate::CreateLambda([WeakSelf, InPath](float) -> bool
    {
        TSharedPtr<FX_AssetNamingDelegates> SharedThis = WeakSelf.Pin();
        if (!SharedThis.IsValid() || !SharedThis->bIsActive)
        {
            return false;
        }

        // 获取该路径下的所有资产
        FAssetRegistryModule& AssetRegistryModule = FModuleManager::LoadModuleChecked<FAssetRegistryModule>("AssetRegistry");
        IAssetRegistry& AssetRegistry = AssetRegistryModule.Get();

        TArray<FAssetData> AssetsInPath;
        AssetRegistry.GetAssetsByPath(FName(*InPath), AssetsInPath, true);

        // 对最近添加的资产进行检查
        for (const FAssetData& AssetData : AssetsInPath)
        {
            if (SharedThis->ShouldProcessAsset(AssetData))
            {
                SharedThis->RenameCallback.Execute(AssetData);
            }
        }

        return false;
    }), 1.0f);  // 延迟 1 秒执行
}
```

### 方案 C：降低启动延迟（简单，缓解问题）

**修改配置默认值**

```cpp
// Source/X_AssetEditor/Private/Settings/X_AssetEditorSettings.cpp

UX_AssetEditorSettings::UX_AssetEditorSettings()
{
    // ... 其他初始化 ...

    // 降低启动延迟（从 30 秒改为 5 秒）
    StartupActivationDelay = 5.0f;

    // 降低 Factory 时间窗（从 5.0 秒改为 10.0 秒，捕获更多场景）
    FactoryCreationTimeWindow = 10.0f;
}
```

## 推荐实施步骤

### 阶段 1：快速修复（立即部署）

1. **降低启动延迟**：`StartupActivationDelay: 30.0f → 5.0f`
2. **增大 Factory 时间窗**：`FactoryCreationTimeWindow: 5.0f → 10.0f`
3. **移除严格的 Factory 时间窗检查**：将硬性过滤改为软性提示

### 阶段 2：完善检测（下个版本）

1. **添加文件时间戳备用通道**
2. **添加 OnPathAdded 监听**
3. **优化日志输出**，便于诊断问题

### 阶段 3：高级特性（未来版本）

1. **配置化检测策略**：允许用户选择检测方式
2. **白名单机制**：对特定路径/类型强制启用重命名
3. **手动触发**：提供"重命名最近导入"的命令

## 参考资料

- [UFactory 文档](https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Editor/UnrealEd/UFactory)
- [UImportSubsystem 文档](https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Editor/UnrealEd/UImportSubsystem)
- [FAssetRegistry 文档](https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/AssetRegistry)
- [UE 论坛: Import modifications](https://forums.unrealengine.com/t/where-can-i-write-modifications-to-the-asset-import-pipeline/839)

## 测试用例

修复后应测试以下场景：

| 场景 | 当前状态 | 预期状态 |
|------|---------|---------|
| Content Browser → Import | ✅ 工作 | ✅ 工作 |
| 拖拽单个文件 | ❌ 不工作 | ✅ 工作 |
| 拖拽多个文件 | ❌ 不工作 | ✅ 工作 |
| 启动时立即导入 | ❌ 不工作 | ✅ 工作 |
| 脚本自动化导入 | ❓ 未知 | ✅ 工作 |
| 复制粘贴资产 | ❌ 不应工作 | ❌ 不应工作 |
