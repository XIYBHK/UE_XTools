name: Êõ¥Êñ∞ÂèëË°åÁâàËµÑ‰∫ß

on:
  workflow_run:
    workflows: ["Build XTools Plugin (Optimized BuildPlugin)"]
    types:
      - completed

  workflow_dispatch:
    inputs:
      update_mode:
        description: 'Êõ¥Êñ∞Ê®°Âºè'
        required: false
        type: choice
        default: 'latest'
        options:
          - latest
          - custom
      custom_tag:
        description: 'Ëá™ÂÆö‰πâÁâàÊú¨Âè∑Ôºà‰ªÖÂú®ÈÄâÊã©customÊó∂ÈúÄË¶ÅÔºåÂ¶ÇÔºöv1.9.2Ôºâ'
        required: false
        type: string

# ÈªòËÆ§ÊùÉÈôêÔºöÂè™ËØªÔºàÈÅµÂæ™ÊúÄÂ∞èÊùÉÈôêÂéüÂàôÔºâ
permissions:
  contents: read

jobs:
  update-assets:
    # Âè™Âú®ÈùûtagÊûÑÂª∫ÊàêÂäüÊó∂ËøêË°åÔºåÊàñÊâãÂä®Ëß¶ÂèëÊó∂ËøêË°å
    # TagÊûÑÂª∫‰ºö‰ΩøÁî®ÂÜÖÁΩÆÁöÑcreate-release job
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event.workflow_run.conclusion == 'success' &&
       !startsWith(github.event.workflow_run.head_branch, 'v'))
    runs-on: [self-hosted, Windows]  # ‰ΩøÁî®Ëá™ÊâòÁÆ°Êú∫Âô®‰ºòÂÖà‰ªéÊú¨Âú∞ËØªÂèñ
    timeout-minutes: 30  # Èò≤Ê≠¢Â∑•‰ΩúÊµÅÊåÇËµ∑

    # Âπ∂ÂèëÊéßÂà∂ÔºöÈò≤Ê≠¢ÂêåÊó∂Êõ¥Êñ∞Âêå‰∏Ä‰∏™ Release
    concurrency:
      group: release-assets-update
      cancel-in-progress: true  # ÂèñÊ∂àÊóßÁöÑÊõ¥Êñ∞Êìç‰ΩúÔºåÂè™‰øùÁïôÊúÄÊñ∞ÁöÑ

    # ÊúÄÂ∞èÊùÉÈôêÔºö‰ªÖÈúÄË¶ÅÂøÖË¶ÅÁöÑÊùÉÈôê
    permissions:
      contents: write  # Êõ¥Êñ∞ Release ËµÑ‰∫ß
      actions: read    # ‰∏ãËΩΩÊûÑÂª∫‰∫ßÁâ©

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Determine target release
        id: target
        uses: actions/github-script@v7
        with:
          script: |
            let tagName = '';
            let runId = '';

            // Â§ÑÁêÜÊâãÂä®Ëß¶Âèë
            if (context.eventName === 'workflow_dispatch') {
              const updateMode = '${{ inputs.update_mode }}';
              if (updateMode === 'custom') {
                tagName = '${{ inputs.custom_tag }}';
                if (!tagName) {
                  console.log('Custom mode requires tag name');
                  core.setOutput('skip', 'true');
                  return;
                }
              }
            }

            // Â¶ÇÊûúÊòØËá™Âä®Ëß¶ÂèëÊàñÊâãÂä®latestÊ®°ÂºèÔºåËé∑ÂèñÊúÄÊñ∞release
            if (!tagName) {
              if (context.eventName === 'workflow_run') {
                runId = String(context.payload.workflow_run.id);
              }

              // Ëé∑ÂèñÊúÄÊñ∞ÁöÑ release
              try {
                const releases = await github.rest.repos.listReleases({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  per_page: 1
                });

                if (releases.data.length > 0) {
                  tagName = releases.data[0].tag_name;
                  console.log(`Will update release: ${tagName}`);
                } else {
                  console.log('No existing release found, skipping update');
                  core.setOutput('skip', 'true');
                  return;
                }
              } catch (error) {
                console.log('Error getting releases:', error.message);
                core.setOutput('skip', 'true');
                return;
              }
            }

            // È™åËØÅ release Â≠òÂú®
            try {
              const release = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: tagName
              });

              console.log(`Found release: ${release.data.name} (ID: ${release.data.id})`);

              core.setOutput('skip', 'false');
              core.setOutput('tagName', tagName);
              core.setOutput('releaseId', String(release.data.id));
              core.setOutput('runId', runId || '');
            } catch (error) {
              console.log(`Release ${tagName} not found:`, error.message);
              core.setOutput('skip', 'true');
            }

      - name: Check if should skip
        if: steps.target.outputs.skip == 'true'
        shell: powershell -ExecutionPolicy Bypass -File {0}
        run: |
          "### ‚è≠Ô∏è Skipping Update" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          "No release to update or release not found." | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          exit 0

      - name: Get build artifacts (local first)
        if: steps.target.outputs.skip != 'true'
        id: get_local
        shell: powershell -ExecutionPolicy Bypass -File {0}
        run: |
          Write-Host "==> Get Build Artifacts" -ForegroundColor Cyan

          $new_assets_dir = ".\new-assets"
          $local_temp_dir = "C:\GitHubActions\ReleaseTemp"

          # Create assets directory
          New-Item -ItemType Directory -Path $new_assets_dir -Force | Out-Null

          # Initialize outputs
          $source_output = "download"
          $success_output = "false"

          # Try local first
          if (Test-Path $local_temp_dir) {
            $local_files = Get-ChildItem -Path $local_temp_dir -Filter "*.zip" -ErrorAction SilentlyContinue

            if ($local_files.Count -gt 0) {
              Write-Host "[Local] Copying $($local_files.Count) files from local temp" -ForegroundColor Green

              foreach ($file in $local_files) {
                Write-Host "  - $($file.Name)"
                Copy-Item $file.FullName -Destination $new_assets_dir -Force
              }

              $source_output = "local"
              $success_output = "true"
            } else {
              Write-Host "[Fallback] Local temp directory exists but no files, will download from Artifacts" -ForegroundColor Yellow
            }
          } else {
            Write-Host "[Fallback] Local temp directory not found, will download from Artifacts" -ForegroundColor Yellow
          }

          # Write outputs at the end
          "source=$source_output" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "success=$success_output" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Download from Artifacts (fallback)
        if: steps.target.outputs.skip != 'true' && steps.get_local.outputs.source == 'download'
        id: download
        uses: actions/github-script@v7
        continue-on-error: false
        with:
          retries: 3
          script: |
            const { execSync } = require('child_process');
            let runId = '${{ steps.target.outputs.runId }}';
            const releaseId = '${{ steps.target.outputs.releaseId }}';

            if (!runId || runId === '') {
              console.log('No run ID specified, getting latest');
              // Ëé∑ÂèñÊúÄÊñ∞ÁöÑÊàêÂäüÊûÑÂª∫
              const runs = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'build-plugin-optimized.yml',
                status: 'success',
                per_page: 1
              });

              if (runs.data.workflow_runs.length === 0) {
                console.log('No successful builds found');
                core.setOutput('success', 'false');
                return;
              }

              runId = runs.data.workflow_runs[0].id;
            }

            console.log(`Downloading artifacts from run ${runId}`);

            // Ëé∑Âèñ artifacts ÂàóË°®
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: runId
            });

            const fs = require('fs');
            const path = require('path');

            // ÂàõÂª∫ÁõÆÂΩï
            const releaseDir = 'new-assets';
            const tempDir = 'temp-download';

            if (!fs.existsSync(tempDir)) {
              fs.mkdirSync(tempDir, { recursive: true });
            }

            let downloadCount = 0;

            // ‰∏ãËΩΩÊØè‰∏™ XTools Áõ∏ÂÖ≥ÁöÑ artifact
            for (const artifact of artifacts.data.artifacts) {
              if (artifact.name.includes('XTools-UE_')) {
                console.log(`\n[${downloadCount}] Downloading: ${artifact.name}`);

                // ‰∏ãËΩΩ ArtifactÔºà‰ºöÂæóÂà∞Â§ñÂ±Ç ZIPÔºâ
                const download = await github.rest.actions.downloadArtifact({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  artifact_id: artifact.id,
                  archive_format: 'zip'
                });

                // ‰øùÂ≠òÂ§ñÂ±Ç ZIP
                const tempZipPath = path.join(tempDir, `${artifact.name}-outer.zip`);
                fs.writeFileSync(tempZipPath, Buffer.from(download.data));
                console.log(`  Saved outer ZIP: ${tempZipPath}`);

                // Ëß£ÂéãÂ§ñÂ±Ç ZIPÔºåÊèêÂèñÂÜÖÈÉ®ÁöÑÂéüÂßã ZIP Êñá‰ª∂
                try {
                  const extractedDir = path.join(tempDir, artifact.name);
                  execSync(`powershell -Command "Expand-Archive -Path '${tempZipPath}' -DestinationPath '${extractedDir}' -Force"`, { stdio: 'inherit' });

                  // Êü•ÊâæÂÜÖÈÉ®ÁöÑ .zip Êñá‰ª∂
                  const innerZips = fs.readdirSync(extractedDir).filter(f => f.endsWith('.zip'));

                  if (innerZips.length > 0) {
                    // ÁßªÂä®ÂÜÖÈÉ® ZIP Âà∞ÂèëÂ∏ÉÁõÆÂΩï
                    const innerZipPath = path.join(extractedDir, innerZips[0]);
                    const destPath = path.join(releaseDir, innerZips[0]);
                    fs.copyFileSync(innerZipPath, destPath);
                    console.log(`  ‚úì Extracted: ${innerZips[0]}`);
                    downloadCount++;
                  } else {
                    console.log(`  ‚ö† No inner ZIP found, artifact may not be nested`);
                  }
                } catch (error) {
                  console.error(`  ‚úó Failed to extract: ${error.message}`);
                }
              }
            }

            // Ê∏ÖÁêÜ‰∏¥Êó∂ÁõÆÂΩï
            if (fs.existsSync(tempDir)) {
              fs.rmSync(tempDir, { recursive: true, force: true });
            }

            console.log(`\n‚úì Downloaded and extracted ${downloadCount} files`);

            core.setOutput('success', 'true');
            core.setOutput('releaseId', releaseId);

      - name: Update release assets
        if: steps.target.outputs.skip != 'true' && (steps.get_local.outputs.success == 'true' || steps.download.outputs.success == 'true')
        uses: actions/github-script@v7
        continue-on-error: false  # ‰∏ä‰º†Â§±Ë¥•Â∫îÂÅúÊ≠¢ÊµÅÁ®ã
        with:
          retries: 3  # ÁΩëÁªúÊìç‰ΩúÈáçËØï
          script: |
            const releaseIdStr = '${{ steps.target.outputs.releaseId }}';
            const releaseId = parseInt(releaseIdStr, 10);

            const fs = require('fs');
            const path = require('path');

            // ‰ªé new-assets ÁõÆÂΩïËØªÂèñÊâÄÊúâ ZIP Êñá‰ª∂
            const assetsDir = 'new-assets';
            const zipFiles = fs.readdirSync(assetsDir).filter(f => f.endsWith('.zip'));
            const newFiles = zipFiles.map(fileName => ({
              name: fileName,
              path: path.join(assetsDir, fileName)
            }));

            console.log(`Updating release ${releaseId} with ${newFiles.length} files`);

            // Ëé∑ÂèñÁé∞ÊúâËµÑ‰∫ßÂàóË°®
            const existingAssets = await github.rest.repos.listReleaseAssets({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId,
              per_page: 100
            });

            let updatedCount = 0;
            let addedCount = 0;
            let uploadIndex = 0;

            for (const file of newFiles) {
              console.log(`\n[${uploadIndex}/${newFiles.length}] Processing: ${file.name}`);

              // Ê£ÄÊü•ÊòØÂê¶Â∑≤Â≠òÂú®ÂêåÂêçËµÑ‰∫ß
              const existingAsset = existingAssets.data.find(a => a.name === file.name);

              if (existingAsset) {
                console.log(`  üóëÔ∏è Deleting existing asset (id: ${existingAsset.id})`);
                try {
                  await github.rest.repos.deleteReleaseAsset({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    asset_id: existingAsset.id
                  });
                  updatedCount++;
                  console.log(`  ‚úÖ Deleted successfully`);
                } catch (error) {
                  // Â¶ÇÊûúËµÑ‰∫ßÂ∑≤Ë¢´Âà†Èô§Ôºà404ÔºâÔºåÂøΩÁï•ÈîôËØØÁªßÁª≠
                  if (error.status === 404) {
                    console.log(`  ‚ö†Ô∏è Asset already deleted (404), treating as new`);
                    addedCount++;  // ËßÜ‰∏∫Êñ∞Â¢û
                  } else {
                    throw error;  // ÂÖ∂‰ªñÈîôËØØÂàôÊäõÂá∫
                  }
                }
              } else {
                console.log(`  ‚ûï New asset (not found in release)`);
                addedCount++;
              }

              // ‰∏ä‰º†Êñ∞ËµÑ‰∫ß
              const data = fs.readFileSync(file.path);
              console.log(`  üì§ Uploading ${file.name} (${data.length} bytes)...`);

              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: releaseId,
                name: file.name,
                data: data,
                headers: {
                  'content-type': 'application/zip'
                }
              });
              console.log(`  ‚úÖ Upload completed`);
              uploadIndex++;
            }

            console.log(`‚úÖ Updated ${updatedCount} assets, added ${addedCount} new assets`);

            core.setOutput('updated', String(updatedCount));
            core.setOutput('added', String(addedCount));

      - name: Create summary
        if: steps.target.outputs.skip != 'true'
        shell: powershell -ExecutionPolicy Bypass -File {0}
        run: |
          "### üì¶ Release Assets Update Report" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          "" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          "**Target Release**: ${{ steps.target.outputs.tagName }}" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          "" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append

          if (Test-Path "new-assets") {
            "**Updated Files**:" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
            $files = Get-ChildItem -Path "new-assets" -Filter "*.zip" -ErrorAction SilentlyContinue
            if ($files) {
              foreach ($file in $files) {
                $size_mb = [math]::Round($file.Length / 1MB, 2)
                "- ``$($file.Name)`` ($size_mb MB)" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
              }
            }
          }

          "" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          "[View Release](https://github.com/${{ github.repository }}/releases/tag/${{ steps.target.outputs.tagName }})" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append

      - name: Clean up
        if: always()
        shell: powershell -ExecutionPolicy Bypass -File {0}
        run: |
          if (Test-Path "new-assets") {
            Remove-Item -Recurse -Force "new-assets" -ErrorAction SilentlyContinue
          }
          if (Test-Path "release-assets") {
            Remove-Item -Recurse -Force "release-assets" -ErrorAction SilentlyContinue
          }
          if (Test-Path "temp-download") {
            Remove-Item -Recurse -Force "temp-download" -ErrorAction SilentlyContinue
          }